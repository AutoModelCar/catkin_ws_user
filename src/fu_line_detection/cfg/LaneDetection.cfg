#!/usr/bin/env python
PACKAGE = "line_detection_fu"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gen.add("defaultXLeft",    int_t,    0, "LEFT lane border position", 20,  0, 160)
gen.add("defaultXCenter",  int_t,    0, "CENTER lane border position", 60,  0, 160)
gen.add("defaultXRight",   int_t,    0, "RIGHT lane border position", 100,  0, 160)
gen.add("interestDistancePoly",    		int_t,    0, "Accepted horizontal distance between a potential point and a detected polynomial", 5,  0, 100)
gen.add("interestDistanceDefault", 		int_t,    0, "Accepted horizontal distance between a potential point and a default line", 20,  0, 100)
gen.add("iterationsRansac",        		int_t,    0, "Iterations during ransac", 30,  0, 100)
gen.add("maxYRoi",   	   int_t,    0, "Maximum y value for points on a line", 159,  0, 160)
gen.add("minYDefaultRoi",  int_t,    0, "Minimum y value for points to check distance to default lane positions (defaultXLeft etc) ", 110,  0, 160)
gen.add("minYPolyRoi",     int_t,    0, "Minimum y value for points on lane marking if a polynomial was detected in a previous frame", 50,  0, 160)
gen.add("polyY1",     	   int_t,    0, "Y of first point of generated polynomial during ransac iteration. Horizontal distance of this point is compared to default lane and to previous found polynomial.", 155,  0, 160)
gen.add("polyY2",     	   int_t,    0, "Y of second point. See polyY1", 145,  0, 160)
gen.add("polyY3",     	   int_t,    0, "Y of third point. See polyY1", 130,  0, 160)
gen.add("detectLaneStartX",int_t,    0, "X value used for gradient calculation in detectLane", 155,  0, 160)
gen.add("maxAngleDiff",    int_t,    0, "Optional smoothing when angle diff larger than this", 999,  1, 999)
gen.add("proj_y_start",    int_t,    0, "Y position of processed window inside of IPmapped img", 50,  0, 80)
gen.add("roi_top_w",       int_t,    0, "Width of top of roi", 70,  0, 160)
gen.add("roi_bottom_w",                 int_t,    0, "Width of bottom of roi", 70,  0, 160)
gen.add("proportionThreshould",    		double_t, 0, "Minimum proportion of supporter points for possible polynomial to accept polynomial as valid during ransac iteration",    .6, 0,   1)
gen.add("m_gradientThreshold",    		int_t,    0, "Edge Detection: Minimum value of sum after applying kernel", 10,  0, 100)
gen.add("m_nonMaxWidth",   				int_t,    0, "Edge Detection: Minimum width between 2 maxima points on a scanline", 10,  0, 100)
gen.add("laneMarkingSquaredThreshold",  int_t,    0, "Lane Extraction: Maximum value of squared subtraction of possible start and end point of lane marking", 36,  0, 100)
gen.add("angleAdjacentLeg",   			int_t,    0, "-Y position of where the angle of polynomial is computed", 100,  0, 160)
gen.add("scanlinesVerticalDistance",   	int_t,    0, "Distance between 2 vertical scanlines", 2,  0, 160)
gen.add("scanlinesMaxCount",   			int_t,    0, "Maximum of scanlines", 100,  0, 160)

exit(gen.generate(PACKAGE, "line_detection_fu", "LaneDetection"))

